function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

import * as React from 'react';
import { View } from 'react-native';
import Animated, { useAnimatedStyle } from 'react-native-reanimated';
import { SafeAreaView } from 'react-native-safe-area-context';
import { commonStyles } from '../../constants';
import { withStickyHeaderFlashList } from '../../primitiveComponents/withStickyHeaderFlashList';
import { parseAnimatedColorProp } from '../common/utils/parseAnimatedColorProp';
import { HeaderBar } from './components/HeaderBar';
import { useTabbedFlashListHeader } from './hooks/useTabbedFlashListHeader';
export function withTabbedHeaderFlashList(flashListComponent) {
  const StickyHeaderFlashList = withStickyHeaderFlashList(flashListComponent);
  return /*#__PURE__*/React.forwardRef((props, ref) => {
    const {
      backgroundColor,
      decelerationRate = 'fast',
      enableSafeAreaTopInset = true,
      logo,
      logoContainerStyle,
      logoResizeMode,
      logoStyle,
      nestedScrollEnabled = true,
      overScrollMode = 'never',
      renderHeader,
      renderHeaderBar,
      scrollEventThrottle = 16,
      viewabilityConfig = {
        itemVisiblePercentThreshold: 50
      },
      ...rest
    } = props;
    const {
      onMomentumScrollEnd,
      onScroll,
      onScrollEndDrag,
      onViewableItemsChanged,
      renderHeader: defaultRenderHeader,
      renderTabs,
      scrollViewRef
    } = useTabbedFlashListHeader(props);
    React.useImperativeHandle(ref, () => scrollViewRef.current);
    const wrapperAnimatedStyle = useAnimatedStyle(() => {
      return {
        backgroundColor: parseAnimatedColorProp(backgroundColor)
      };
    }, [backgroundColor]);
    return /*#__PURE__*/React.createElement(Animated.View, {
      style: [commonStyles.container, wrapperAnimatedStyle]
    }, renderHeaderBar ? renderHeaderBar() : logo ? /*#__PURE__*/React.createElement(HeaderBar, {
      backgroundColor: backgroundColor,
      enableSafeAreaTopInset: enableSafeAreaTopInset,
      logo: logo,
      logoContainerStyle: logoContainerStyle,
      logoResizeMode: logoResizeMode,
      logoStyle: logoStyle
    }) : /*#__PURE__*/React.createElement(SafeAreaView, {
      edges: ['left', 'right', ...(enableSafeAreaTopInset ? ['top'] : [])],
      style: commonStyles.stretch
    }), /*#__PURE__*/React.createElement(View, {
      style: commonStyles.wrapper
    }, /*#__PURE__*/React.createElement(StickyHeaderFlashList, _extends({
      ref: scrollViewRef
    }, rest, {
      decelerationRate: decelerationRate,
      nestedScrollEnabled: nestedScrollEnabled,
      overScrollMode: overScrollMode,
      scrollEventThrottle: scrollEventThrottle,
      viewabilityConfig: viewabilityConfig,
      renderHeader: renderHeader !== null && renderHeader !== void 0 ? renderHeader : defaultRenderHeader,
      renderTabs: renderTabs,
      onScroll: onScroll,
      onScrollEndDrag: onScrollEndDrag,
      onMomentumScrollEnd: onMomentumScrollEnd,
      onViewableItemsChanged: onViewableItemsChanged
    }))));
  });
}
//# sourceMappingURL=withTabbedHeaderFlashList.js.map